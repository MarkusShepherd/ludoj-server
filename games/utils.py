# -*- coding: utf-8 -*-

""" utils """

import logging
import os.path
import timeit

from datetime import timezone
from functools import lru_cache

from django.conf import settings
from pytility import parse_date

LOGGER = logging.getLogger(__name__)


def format_from_path(path):
    """ get file extension """
    try:
        _, ext = os.path.splitext(path)
        return ext.lower()[1:] if ext else None
    except Exception:
        pass
    return None


def serialize_date(date, tzinfo=None):
    """seralize a date into ISO format if possible"""
    parsed = parse_date(date, tzinfo)
    return parsed.strftime("%Y-%m-%dT%T%z") if parsed else str(date) if date else None


@lru_cache(maxsize=8)
def load_recommender(path, site="bgg"):
    """ load recommender from given path """
    if not path:
        return None
    try:
        if site == "bga":
            from board_game_recommender import BGARecommender

            return BGARecommender.load(path=path)
        from board_game_recommender import BGGRecommender

        return BGGRecommender.load(path=path)
    except Exception:
        LOGGER.exception("unable to load recommender model from <%s>", path)
    return None


@lru_cache(maxsize=8)
def pubsub_client():
    """ Google Cloud PubSub client """
    try:
        from google.cloud import pubsub

        return pubsub.PublisherClient()
    except Exception:
        LOGGER.exception("unable to initialise PubSub client")
    return None


def pubsub_push(
    message,
    project=settings.PUBSUB_QUEUE_PROJECT,
    topic=settings.PUBSUB_QUEUE_TOPIC,
    encoding="utf-8",
    **kwargs,
):
    """ publish message """

    if not project or not topic:
        return None

    client = pubsub_client()

    if client is None:
        return None

    if isinstance(message, str):
        message = message.encode(encoding)
    assert isinstance(message, bytes)

    # pylint: disable=no-member
    path = client.topic_path(project, topic)

    LOGGER.debug("pushing message %r to <%s>", message, path)

    try:
        return client.publish(topic=path, data=message, **kwargs)
    except Exception:
        LOGGER.exception("unable to send message %r", message)
    return None


@lru_cache(maxsize=8)
def model_updated_at(file_path=settings.MODEL_UPDATED_FILE):
    """ latest model update """
    try:
        with open(file_path) as file_obj:
            updated_at = file_obj.read()
        updated_at = " ".join(updated_at.split())
        return parse_date(updated_at, tzinfo=timezone.utc)
    except Exception:
        pass
    return None


def save_recommender_ranking(recommender, dst, similarity_model=False):
    """Save the rankings generated by a recommender to a CSV file."""

    LOGGER.info(
        "Saving <%s> ranking to <%s>...",
        recommender.similarity_model if similarity_model else recommender.model,
        dst,
    )

    recommendations = recommender.recommend(similarity_model=similarity_model)
    if "name" in recommendations.column_names():
        recommendations.remove_column("name", inplace=True)

    if similarity_model:
        recommendations = recommendations[recommendations["score"] > 0]

    recommendations.export_csv(str(dst))


class Timer:
    """ log execution time: with Timer('message'): do_something() """

    def __init__(self, message, logger=None):
        self.message = f'"{message}" execution time: %.1f ms'
        self.logger = logger
        self.start = None

    def __enter__(self):
        self.start = timeit.default_timer()
        return self

    def __exit__(self, *args, **kwargs):
        duration = 1000 * (timeit.default_timer() - self.start)
        if self.logger is None:
            print(self.message % duration)
        else:
            self.logger.info(self.message, duration)
